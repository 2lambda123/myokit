<?
# Template for Chaste model implementation.
#
# Variables:
#   class_name      A valid camel cased class name
#   code_name       A model name usable in variables etc.
#   ewriter         An expression writer
#   header_file     The name of the accompanying header file
#   model           A model object
#   model_name      A user friendly model name (arbitrary string)
#   var_name        A method that creates variable names
#   vm              The state variable representing membrane potential
#

# Common strings
tab = '    '

?>//! @file
//!
//! This source file was generated by Myokit
//!
//! Model: <?= model_name ?>
//!
//! <autogenerated>

#include "<?= header_file ?>"
#include <cmath>
#include <cassert>
#include <memory>
#include "Exception.hpp"
#include "OdeSystemInformation.hpp"
#include "RegularStimulus.hpp"
#include "HeartConfig.hpp"
#include "IsNan.hpp"
#include "MathsCustomFunctions.hpp"

    <?= class_name ?>::<?= class_name ?>(boost::shared_ptr<AbstractIvpOdeSolver> pSolver, boost::shared_ptr<AbstractStimulusFunction> pIntracellularStimulus)
        : AbstractCardiacCell(
                pSolver,
                <?= model.count_states() ?>,
                <?= vm.indice() ?>,
                pIntracellularStimulus)
    {
        // Time units: millisecond
        //
        this->mpSystemInfo = OdeSystemInformation<<?= class_name ?>>::Instance();
        Init();
    }

    <?= class_name ?>::~<?= class_name ?>()
    {
    }

    double <?= class_name ?>::GetIIonic(const std::vector<double>* pStateVariables)
    {
        // For state variable interpolation (SVI) we read in interpolated state variables,
        // otherwise for ionic current interpolation (ICI) we use the state variables of this model (node).
        if (!pStateVariables) pStateVariables = &rGetStateVariables();
        const std::vector<double>& rY = *pStateVariables;
        {% for state_var in state_vars %}
        {%- if state_var.in_ionic %}double {{ state_var.var }} = {% if loop.index0 == membrane_voltage_index %}(mSetVoltageDerivativeToZero ? this->mFixedVoltage : rY[{{loop.index0}}]);{%- else %}rY[{{loop.index0}}];{%- endif %}
        // Units: {{state_var.units}}; Initial value: {{state_var.initial_value}}
        {% endif %}
        {%- endfor %}
        {% for ionic_var in ionic_vars %}
        const double {{ionic_var.lhs}} = {{ionic_var.rhs}}; // {{ionic_var.units}}
        {%- endfor %}

        //TODO:
        // const double var_chaste_interface__i_ionic = (var_L_type_Ca_current__i_CaL + var_calcium_background_current__i_b_Ca + var_calcium_pump_current__i_p_Ca + var_fast_sodium_current__i_Na + var_inward_rectifier_potassium_current__i_K1 + var_potassium_pump_current__i_p_K + var_rapid_time_dependent_potassium_current__i_Kr + var_slow_time_dependent_potassium_current__i_Ks + var_sodium_background_current__i_b_Na + var_sodium_calcium_exchanger_current__i_NaCa + var_sodium_potassium_pump_current__i_NaK + var_transient_outward_current__i_to) * HeartConfig::Instance()->GetCapacitance(); // uA_per_cm2

        const double i_ionic = var_chaste_interface__i_ionic;
        EXCEPT_IF_NOT(!std::isnan(i_ionic));
        return i_ionic;
    }

    void <?= class_name ?>::EvaluateYDerivatives(double <?= var_name(model.time()) ?>, const std::vector<double>& rY, std::vector<double>& rDY)
    {
        // Inputs:
        // Time units: millisecond
<?
for var in model.states():
    rhs = 'rY[' + str(var.indice()) + ']'
    if var is vm:
        rhs = '(mSetVoltageDerivativeToZero ? this->mFixedVoltage : ' + rhs
    print(tab*2 + 'double ' + var_name(var) + ' = ' + rhs + ';')
    print(tab*2 + '// Units: ' + str(var.unit()) + '; Initial value: ' + str(var.state_value()))
?>

        //TODO:
        // const double var_membrane__i_Stim_converter = GetIntracellularAreaStimulus(var_chaste_interface__environment__time); // uA_per_cm2
        // const double var_membrane__i_Stim = var_membrane__i_Stim_converter / HeartConfig::Instance()->GetCapacitance(); // picoA_per_picoF

        // Mathematics
<?
for eqs in model.solvable_order().values():
    for eq in eqs.equations():
        var = eq.lhs.var()
        if var is vm:
            print(tab*2 + 'double ' + var_name(eq.lhs) + ' = 0;')
            print(tab*2 + 'if (!mSetVoltageDerivativeToZero)')
            print(tab*2 + '{')
            print(tab*3 + ewriter.eq(eq) + ';')
            print(tab*2 + '}')
        else:
            print(tab*2 + 'const double ' + ewriter.eq(eq) + ';')
?>
        // Outputs:
<?
for var in model.states():
    print(tab*2 + 'rDY[' + str(var.indice()) + '] = ' + var_name(var.lhs()) + ';')
?>    }

template<>
void OdeSystemInformation<<?= class_name ?>>::Initialise(void)
{
    this->mSystemName = "<?= code_name ?>";
    this->mFreeVariableName = "<?= model.time().uname() ?>";
    this->mFreeVariableUnits = "millisecond";
<?
for var in model.states():
    print()
    print(tab + 'this->mVariableNames.push_back("' + var.uname() + '");')
    print(tab + 'this->mVariableUnits.push_back("' + str(var.unit()) + '");')
    print(tab + 'this->mInitialConditions.push_back(' + str(var.state_value()) + ');')
?>
    this->mAttributes["SuggestedForwardEulerTimestep"] = 0.001;
    this->mInitialised = true;
}


// Serialization for Boost >= 1.36
#include "SerializationExportWrapperForCpp.hpp"
CHASTE_CLASS_EXPORT(<?= class_name ?>)

